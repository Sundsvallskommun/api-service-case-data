package se.sundsvall.casedata.integration.landandexploitation;

import static org.zalando.problem.Status.SERVICE_UNAVAILABLE;
import static se.sundsvall.casedata.service.util.Constants.PROCESS_ENGINE_PROBLEM_DETAIL;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.zalando.problem.AbstractThrowableProblem;
import org.zalando.problem.Problem;

import se.sundsvall.casedata.integration.db.model.Errand;

import generated.se.sundsvall.parkingpermit.StartProcessResponse;

@Component
public class LandAndExploitationIntegration {

	private static final String COULD_NOT_START_PROCESS = "Could not start process for errand with casetype: %s and errandId: %s, with error: %s";
	private static final String COULD_NOT_UPDATE_PROCESS = "Could not update process for errand with casetype: %s and processId: %s, with error: %s";
	private static final Logger LOGGER = LoggerFactory.getLogger(LandAndExploitationIntegration.class);

	private final LandAndExploitationClient landAndExploitationClient;

	public LandAndExploitationIntegration(final LandAndExploitationClient landAndExploitationClient) {
		this.landAndExploitationClient = landAndExploitationClient;
	}

	public StartProcessResponse startProcess(final Errand errand) {
		try {
			return landAndExploitationClient.startProcess(errand.getMunicipalityId(), errand.getId());
		} catch (final AbstractThrowableProblem e) {
			LOGGER.warn(COULD_NOT_START_PROCESS.formatted(errand.getCaseType(), errand.getId(), e));
			throw Problem.valueOf(SERVICE_UNAVAILABLE, PROCESS_ENGINE_PROBLEM_DETAIL);
		}
	}

	public void updateProcess(final Errand errand) {
		try {
			landAndExploitationClient.updateProcess(errand.getMunicipalityId(), errand.getProcessId());
		} catch (final AbstractThrowableProblem e) {
			LOGGER.warn(COULD_NOT_UPDATE_PROCESS.formatted(errand.getCaseType(), errand.getProcessId(), e));
			throw Problem.valueOf(SERVICE_UNAVAILABLE, PROCESS_ENGINE_PROBLEM_DETAIL);
		}
	}
}
